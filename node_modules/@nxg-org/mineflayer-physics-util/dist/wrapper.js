"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PhysicsUtilWrapper = exports.SimulationTypes = void 0;
const engines_1 = require("./physics/engines");
const settings_1 = require("./physics/settings");
const simulators_1 = require("./simulators");
/**
 * Just a convenience thing.
 */
var SimulationTypes;
(function (SimulationTypes) {
    SimulationTypes[SimulationTypes["UNTIL_GROUND"] = 0] = "UNTIL_GROUND";
    SimulationTypes[SimulationTypes["FOR_X_TICKS"] = 1] = "FOR_X_TICKS";
    SimulationTypes[SimulationTypes["TO_DESTINATION"] = 2] = "TO_DESTINATION";
})(SimulationTypes = exports.SimulationTypes || (exports.SimulationTypes = {}));
class PhysicsUtilWrapper {
    constructor(bot) {
        this.bot = bot;
        this.physicsSettings = settings_1.PhysicsSettings;
        this.ePhysicsCtx = settings_1.EPhysicsCtx;
        this.data = bot.registry;
        settings_1.PhysicsSettings.loadData(this.data);
        settings_1.EPhysicsCtx.loadData(this.data);
        this.engine = new engines_1.EntityPhysics(this.data);
    }
    getPhysicsSim() {
        return new engines_1.EntityPhysics(this.data);
    }
    getPhysicsCtx(ctx, entity) {
        return settings_1.EPhysicsCtx.FROM_ENTITY(ctx, entity);
    }
    getPhysicsCtxRaw(ctx, entity, options = {}) {
        return settings_1.EPhysicsCtx.FROM_ENTITY_TYPE(ctx, entity, options);
    }
    simulate(simulator, simCtx, world) {
        return simulator.simulate(simCtx, world);
    }
    exampleSim(entity, type, ticks = 10, destination) {
        const simulator = new simulators_1.BasicSim(new engines_1.EntityPhysics(this.data));
        switch (type) {
            case SimulationTypes.FOR_X_TICKS:
                return simulator.simXTicks(entity, this.bot.world, ticks);
            case SimulationTypes.UNTIL_GROUND:
                return simulator.simUntilOnGround(entity, this.bot.world, ticks);
            case SimulationTypes.TO_DESTINATION:
                if (!destination)
                    throw "Invalid destination for example sim.";
                return simulator.simUntilDestination(entity, destination, this.bot.world, ticks);
        }
    }
    advancedExample(simCtx, type, ticks = 10, destination) {
        const simulator = new simulators_1.BasicSim(new engines_1.EntityPhysics(this.data));
        switch (type) {
            case SimulationTypes.FOR_X_TICKS:
                return simulator.simXTicksPrebuilt(simCtx, this.bot.world, ticks);
            case SimulationTypes.UNTIL_GROUND:
                return simulator.simUntilOnGroundPrebuilt(simCtx, this.bot.world, ticks);
            case SimulationTypes.TO_DESTINATION:
                if (!destination)
                    throw "Invalid destination for example sim.";
                return simulator.simUntilDestinationPrebuilt(simCtx, destination, this.bot.world, ticks);
        }
    }
}
exports.PhysicsUtilWrapper = PhysicsUtilWrapper;
