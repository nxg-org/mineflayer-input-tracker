"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasicSim = void 0;
const physicsUtils_1 = require("../util/physicsUtils");
const settings_1 = require("../physics/settings");
const baseSimulator_1 = require("./baseSimulator");
class BasicSim extends baseSimulator_1.BaseSimulator {
    constructor(ctx) {
        super(ctx);
        this.ctx = ctx;
    }
    simXTicksRaw(mdEntity, world, ticks = 5, options = {}) {
        return this.simXTicks((0, physicsUtils_1.applyMdToNewEntity)(settings_1.EPhysicsCtx, mdEntity, options), world, ticks);
    }
    simXTicks(entity, world, ticks) {
        return this.simulateUntil((state) => false, () => { }, () => { }, settings_1.EPhysicsCtx.FROM_ENTITY(this.ctx, entity), world, ticks);
    }
    simXTicksPrebuilt(ctx, world, ticks) {
        return this.simulateUntil((state) => false, () => { }, () => { }, ctx, world, ticks);
    }
    simUntilOnGroundRaw(mdEntity, world, ticks = 5, options = {}) {
        return this.simUntilOnGround((0, physicsUtils_1.applyMdToNewEntity)(settings_1.EPhysicsCtx, mdEntity, options), world, ticks);
    }
    simUntilOnGround(entity, world, ticks = 5) {
        return this.simulateUntil((state) => state.onGround === true, () => { }, () => { }, settings_1.EPhysicsCtx.FROM_ENTITY(this.ctx, entity), world, ticks);
    }
    simUntilOnGroundPrebuilt(ctx, world, ticks = 5) {
        return this.simulateUntil((state) => state.onGround === true, () => { }, () => { }, ctx, world, ticks);
    }
    simUntilDestinationRaw(mdEntity, destination, world, ticks = 5, options = {}) {
        return this.simUntilDestination((0, physicsUtils_1.applyMdToNewEntity)(settings_1.EPhysicsCtx, mdEntity, options), destination, world, ticks);
    }
    simUntilDestination(entity, destination, world, ticks = 10) {
        return this.simulateUntil(BasicSim.getReached(destination), () => { }, () => { }, settings_1.EPhysicsCtx.FROM_ENTITY(this.ctx, entity), world, ticks);
    }
    simUntilDestinationPrebuilt(ctx, destination, world, ticks = 10) {
        return this.simulateUntil(BasicSim.getReached(destination), () => { }, () => { }, ctx, world, ticks);
    }
}
exports.BasicSim = BasicSim;
