import { ControlStateHandler } from "../physics/player";
import { EPhysicsCtx } from "../physics/settings";
import { EntityState } from "../physics/states";
import { IPhysics } from "../physics/engines";
import { Entity } from "prismarine-entity";
import { Vec3 } from "vec3";
export declare type SimulationGoal = (state: EntityState, ticks: number) => boolean | ((state: EntityState) => boolean);
export declare type OnGoalReachFunction = (state: EntityState) => void;
export declare type Controller = (state: EntityState, ticks: number) => void;
export declare abstract class BaseSimulator {
    readonly ctx: IPhysics;
    constructor(ctx: IPhysics);
    predictGenerator(simCtx: EPhysicsCtx, world: any, ticks?: number, controls?: ControlStateHandler): Generator<EntityState, EPhysicsCtx, unknown>;
    predictForward(target: Entity, world: any, ticks?: number, controls?: ControlStateHandler): EntityState;
    predictForwardRaw(simCtx: EPhysicsCtx, world: any, ticks?: number, controls?: ControlStateHandler): EntityState;
    simulateUntil(goal: SimulationGoal, onGoalReach: OnGoalReachFunction, controller: Controller, simCtx: EPhysicsCtx, world: any, ticks?: number): EntityState;
    static getReached(...path: Vec3[]): SimulationGoal;
    static getCleanupPosition(...path: Vec3[]): OnGoalReachFunction;
    static buildFullController(...controllers: Controller[]): Controller;
    static buildAnyGoal(...goals: SimulationGoal[]): SimulationGoal;
    static buildAllGoal(...goals: SimulationGoal[]): SimulationGoal;
}
