"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseSimulator = void 0;
const settings_1 = require("../physics/settings");
class BaseSimulator {
    constructor(ctx) {
        this.ctx = ctx;
    }
    *predictGenerator(simCtx, world, ticks = 1, controls) {
        simCtx.state.controlState = controls !== null && controls !== void 0 ? controls : simCtx.state.controlState;
        for (let current = 0; current < ticks; current++) {
            yield this.ctx.simulate(simCtx, world);
        }
        return simCtx;
    }
    predictForward(target, world, ticks = 1, controls) {
        const simCtx = settings_1.EPhysicsCtx.FROM_ENTITY(this.ctx, target);
        simCtx.state.controlState = controls !== null && controls !== void 0 ? controls : simCtx.state.controlState;
        for (let current = 0; current < ticks; current++) {
            this.ctx.simulate(simCtx, world);
        }
        return simCtx.state;
    }
    predictForwardRaw(simCtx, world, ticks = 1, controls) {
        simCtx.state.controlState = controls !== null && controls !== void 0 ? controls : simCtx.state.controlState;
        for (let current = 0; current < ticks; current++) {
            this.ctx.simulate(simCtx, world);
        }
        return simCtx.state;
    }
    simulateUntil(goal, onGoalReach, controller, simCtx, world, ticks = 1) {
        for (let i = 0; i < ticks; i++) {
            if (goal(simCtx.state, i)) {
                onGoalReach(simCtx.state);
                break;
            }
            if (simCtx.state.isInLava)
                break;
            controller(simCtx.state, i);
            this.ctx.simulate(simCtx, world);
            simCtx.state.age++;
        }
        return simCtx.state;
    }
    static getReached(...path) {
        return (state) => {
            const delta = path[0].minus(state.position);
            return Math.abs(delta.x) <= 0.35 && Math.abs(delta.z) <= 0.35 && Math.abs(delta.y) < 1 && (state.onGround || state.isInWater);
        };
    }
    static getCleanupPosition(...path) {
        return (state) => {
            state.clearControlStates();
        };
    }
    static buildFullController(...controllers) {
        return (state, ticks) => {
            controllers.forEach((control) => control(state, ticks));
        };
    }
    static buildAnyGoal(...goals) {
        return (state, ticks) => goals.map((goal) => goal(state, ticks)).some(g => !!g);
    }
    static buildAllGoal(...goals) {
        return (state, ticks) => goals.map((goal) => goal(state, ticks)).every(g => !!g);
    }
}
exports.BaseSimulator = BaseSimulator;
