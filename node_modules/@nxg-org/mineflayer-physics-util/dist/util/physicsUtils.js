"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBetweenRectangle = exports.getEnchantmentNamesForVersion = exports.getStatusEffectNamesForVersion = exports.whichHandIsEntityUsingBoolean = exports.whichHandIsEntityUsing = exports.isEntityUsingItem = exports.CheapEnchantments = exports.CheapEffects = exports.applyMdToNewEntity = exports.DefaultPlayer = exports.makeSupportFeature = void 0;
const mineflayer_util_plugin_1 = require("@nxg-org/mineflayer-util-plugin");
const features_json_1 = __importDefault(require("../physics/info/features.json"));
function makeSupportFeature(mcData) {
    return (feature) => features_json_1.default.some(({ name, versions }) => name === feature && versions.includes(mcData.version.majorVersion));
}
exports.makeSupportFeature = makeSupportFeature;
exports.DefaultPlayer = {
    displayName: "Player",
    height: 1.8,
    width: 0.6,
    type: "player",
    name: "player",
    id: -1
};
function applyMdToNewEntity(ctx, entityType = exports.DefaultPlayer, options = {}) {
    var _a, _b;
    //entityType.category
    // entityType.internalId
    const tmp = new ctx.entityConstructor(-1);
    tmp.displayName = entityType.displayName;
    tmp.height = (_a = entityType.height) !== null && _a !== void 0 ? _a : 0;
    tmp.width = (_b = entityType.width) !== null && _b !== void 0 ? _b : 0;
    tmp.type = entityType.type;
    tmp.name = entityType.name;
    Object.assign(tmp, options);
    return tmp;
}
exports.applyMdToNewEntity = applyMdToNewEntity;
var CheapEffects;
(function (CheapEffects) {
    CheapEffects[CheapEffects["JUMP_BOOST"] = 0] = "JUMP_BOOST";
    CheapEffects[CheapEffects["SPEED"] = 1] = "SPEED";
    CheapEffects[CheapEffects["SLOWNESS"] = 2] = "SLOWNESS";
    CheapEffects[CheapEffects["DOLPHINS_GRACE"] = 3] = "DOLPHINS_GRACE";
    CheapEffects[CheapEffects["SLOW_FALLING"] = 4] = "SLOW_FALLING";
    CheapEffects[CheapEffects["LEVITATION"] = 5] = "LEVITATION";
})(CheapEffects = exports.CheapEffects || (exports.CheapEffects = {}));
var CheapEnchantments;
(function (CheapEnchantments) {
    CheapEnchantments[CheapEnchantments["DEPTH_STRIDER"] = 0] = "DEPTH_STRIDER";
})(CheapEnchantments = exports.CheapEnchantments || (exports.CheapEnchantments = {}));
function isEntityUsingItem(entity) {
    return (entity.metadata[8] & 1) > 0;
}
exports.isEntityUsingItem = isEntityUsingItem;
function whichHandIsEntityUsing(entity) {
    return (entity.metadata[8] & 2) > 0 ? "off-hand" : "hand";
}
exports.whichHandIsEntityUsing = whichHandIsEntityUsing;
function whichHandIsEntityUsingBoolean(entity) {
    return (entity.metadata[8] & 2) > 0; // true = offhand, false = hand
}
exports.whichHandIsEntityUsingBoolean = whichHandIsEntityUsingBoolean;
function getStatusEffectNamesForVersion(supportFeature) {
    if (supportFeature("effectNamesAreRegistryNames")) {
        // seems to not matter right now.
        return {
            jumpBoostEffectName: "JumpBoost",
            speedEffectName: "Speed",
            slownessEffectName: "Slowness",
            dolphinsGraceEffectName: "DolphinsGrace",
            slowFallingEffectName: "SlowFalling",
            levitationEffectName: "Levitation",
        };
    }
    else {
        return {
            jumpBoostEffectName: "JumpBoost",
            speedEffectName: "Speed",
            slownessEffectName: "Slowness",
            dolphinsGraceEffectName: "DolphinsGrace",
            slowFallingEffectName: "SlowFalling",
            levitationEffectName: "Levitation",
        };
    }
}
exports.getStatusEffectNamesForVersion = getStatusEffectNamesForVersion;
// lol. In case of expansion, yk.
function getEnchantmentNamesForVersion(supportFeature) {
    return {
        depthStriderEnchantmentName: "depth_strider",
    };
}
exports.getEnchantmentNamesForVersion = getEnchantmentNamesForVersion;
function getBetweenRectangle(src, dest) {
    const outerAABB = new mineflayer_util_plugin_1.AABB(Math.min(src.minX, dest.minX), Math.min(src.minY, dest.minY), Math.min(src.minZ, dest.minZ), Math.max(src.maxX, dest.maxX), Math.max(src.maxY, dest.maxY), Math.max(src.maxZ, dest.maxZ));
    //Math.max() only good for length, otherwise leave because we want good shit.
    const innerAABBWidth = outerAABB.maxX - outerAABB.minX - (src.maxX - src.minX) - (dest.maxX - dest.minX);
    const innerAABBLength = outerAABB.maxZ - outerAABB.minZ - (src.maxZ - src.minZ) - (dest.maxZ - dest.minZ);
    const innerAABBHeight = outerAABB.maxY - outerAABB.minY - (src.maxY - src.minY) - (dest.maxY - dest.minY);
    //hm... could make a new AABB representing inner here.
    const outerCenter = outerAABB.getCenter();
    const wFlip = Math.sign(innerAABBWidth);
    const hFlip = Math.sign(innerAABBHeight);
    const lFlip = Math.sign(innerAABBLength);
    const innerAABB = new mineflayer_util_plugin_1.AABB(outerCenter.x - (wFlip * innerAABBWidth) / 2, outerCenter.y - (hFlip * innerAABBHeight) / 2, outerCenter.z - (lFlip * innerAABBLength) / 2, outerCenter.x + (wFlip * innerAABBWidth) / 2, outerCenter.y + (hFlip * innerAABBHeight) / 2, outerCenter.z + (lFlip * innerAABBLength) / 2);
    return innerAABB;
}
exports.getBetweenRectangle = getBetweenRectangle;
