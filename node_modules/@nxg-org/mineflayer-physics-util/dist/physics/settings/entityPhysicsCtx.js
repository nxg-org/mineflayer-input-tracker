"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EPhysicsCtx = exports.emptyVec = void 0;
const mineflayer_util_plugin_1 = require("@nxg-org/mineflayer-util-plugin");
const prismarine_entity_1 = __importDefault(require("prismarine-entity"));
const vec3_1 = require("vec3");
const physicsUtils_1 = require("../../util/physicsUtils");
const entityState_1 = require("../states/entityState");
const poses_1 = require("../states/poses");
const entity_physics_json_1 = __importDefault(require("../info/entity_physics.json"));
function getPose(entity) {
    const pose = entity.metadata.find((e) => { var _a; return ((_a = e) === null || _a === void 0 ? void 0 : _a.type) === 18; });
    return pose ? pose.value : poses_1.PlayerPoses.STANDING;
}
function load(data) {
    EPhysicsCtx.mcData = data;
    EPhysicsCtx.entityData = data["entitiesByName"];
    EPhysicsCtx.mobData = data["mobs"];
    EPhysicsCtx.entityConstructor = prismarine_entity_1.default(data.version.minecraftVersion);
}
exports.emptyVec = new vec3_1.Vec3(0, 0, 0);
class EPhysicsCtx {
    constructor(ctx, pose, state, entityType = physicsUtils_1.DefaultPlayer) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        this.ctx = ctx;
        this.pose = pose;
        this.state = state;
        this.entityType = entityType;
        this.stepHeight = 0;
        this.gravity = 0.0;
        this.airdrag = Math.fround(1 - 0.0);
        this.airborneInertia = 0.91;
        this.airborneAccel = 0.02;
        this.waterInertia = 0.8;
        this.lavaInertia = 0.5;
        this.liquidAccel = 0.02;
        this.gravityThenDrag = false;
        this.useControls = false;
        this.collisionBehavior = {
            blockEffects: false,
            affectedAfterCollision: true,
        };
        this.position = state.position;
        this.velocity = state.velocity;
        if (entityType.type === "player" || !!EPhysicsCtx.mobData[entityType.id]) {
            // @ts-expect-error
            const additional = entity_physics_json_1.default.living_entities[entityType.type];
            Object.assign(this, entity_physics_json_1.default.living_entities.default, additional);
        }
        else if (entityType.name.includes("experience_orb")) {
            Object.assign(this, entity_physics_json_1.default.other.default);
        }
        else if (entityType.name.includes("spit")) {
            Object.assign(this, entity_physics_json_1.default.projectiles.default, entity_physics_json_1.default.projectiles.llama_spit);
        }
        else {
            switch (entityType.type) {
                case "water_creature":
                case "animal":
                case "hostile":
                case "mob":
                    this.gravity = 0.08;
                    this.airdrag = Math.fround(1 - 0.02);
                    this.gravityThenDrag = true;
                    this.useControls = true;
                    this.stepHeight = 1.0;
                    this.collisionBehavior = {
                        blockEffects: true,
                        affectedAfterCollision: true,
                    };
                case "projectile":
                    this.gravity = 0.03;
                    this.airdrag = Math.fround(1 - 0.01);
                    this.airborneInertia = 0.99;
                    this.airborneAccel = 0.06;
                    this.waterInertia = 0.25;
                    this.lavaInertia = 0;
                    this.liquidAccel = 0.02;
                    this.collisionBehavior = {
                        blockEffects: false,
                        affectedAfterCollision: false,
                    };
                case "orb":
                    this.gravity = 0.03;
                    this.airdrag = Math.fround(1 - 0.02);
                    this.collisionBehavior = {
                        blockEffects: false,
                        affectedAfterCollision: true,
                    };
                case "other":
                    if (entityType.name.includes("minecart") || entityType.name.includes("boat")) {
                        Object.assign(this, entity_physics_json_1.default.dead_vehicles.default, entityType.name === "boat" ? entity_physics_json_1.default.dead_vehicles.boat : undefined);
                    }
                    else if (((_a = entityType.name) === null || _a === void 0 ? void 0 : _a.includes("block")) || ((_b = entityType.name) === null || _b === void 0 ? void 0 : _b.includes("tnt"))) {
                        Object.assign(this, entity_physics_json_1.default.blocks.default);
                    }
                    else if (((_c = entityType.name) === null || _c === void 0 ? void 0 : _c.includes("egg")) ||
                        ((_d = entityType.name) === null || _d === void 0 ? void 0 : _d.includes("snowball")) ||
                        ((_e = entityType.name) === null || _e === void 0 ? void 0 : _e.includes("potion")) ||
                        ((_f = entityType.name) === null || _f === void 0 ? void 0 : _f.includes("pearl"))) {
                        Object.assign(this, entity_physics_json_1.default.projectiles.default);
                    }
                    else if ((_g = entityType.name) === null || _g === void 0 ? void 0 : _g.includes("orb")) {
                        Object.assign(this, entity_physics_json_1.default.other.default);
                    }
                    else if ((_h = entityType.name) === null || _h === void 0 ? void 0 : _h.includes("bobber")) {
                        Object.assign(this, entity_physics_json_1.default.projectiles.default, entity_physics_json_1.default.projectiles.fishing_bobber);
                    }
                    else if ((_j = entityType.name) === null || _j === void 0 ? void 0 : _j.includes("spit")) {
                        Object.assign(this, entity_physics_json_1.default.projectiles.default, entity_physics_json_1.default.projectiles.llama_spit);
                    }
                    else if (((_k = entityType.name) === null || _k === void 0 ? void 0 : _k.includes("arrow")) || ((_l = entityType.name) === null || _l === void 0 ? void 0 : _l.includes("trident"))) {
                        Object.assign(this, entity_physics_json_1.default.projectiles.default, entityType.name.includes("arrow") ? entity_physics_json_1.default.projectiles.arrow : entity_physics_json_1.default.projectiles.trident);
                    }
                    else if (((_m = entityType.name) === null || _m === void 0 ? void 0 : _m.includes("fireball")) || ((_o = entityType.name) === null || _o === void 0 ? void 0 : _o.includes("skull"))) {
                        Object.assign(this, entity_physics_json_1.default.shot_entities.default);
                    }
            }
        }
        if (ctx.supportFeature("independentLiquidGravity")) {
            this.waterGravity = 0.02;
            this.lavaGravity = 0.02;
        }
        else if (ctx.supportFeature("proportionalLiquidGravity")) {
            this.waterGravity = this.gravity / 16;
            this.lavaGravity = this.gravity / 4;
        }
        else {
            this.waterGravity = 0.005;
            this.lavaGravity = 0.02;
        }
    }
    static FROM_BOT(ctx, bot) {
        return new EPhysicsCtx(ctx, getPose(bot.entity), entityState_1.EntityState.CREATE_FROM_BOT(ctx, bot));
    }
    static FROM_ENTITY(ctx, entity) {
        return new EPhysicsCtx(ctx, getPose(entity), entityState_1.EntityState.CREATE_FROM_ENTITY(ctx, entity), EPhysicsCtx.entityData[entity.name]);
    }
    static FROM_ENTITY_TYPE(ctx, entityType, options = {}) {
        const newE = (0, physicsUtils_1.applyMdToNewEntity)(EPhysicsCtx, entityType, options);
        return new EPhysicsCtx(ctx, poses_1.PlayerPoses.STANDING, entityState_1.EntityState.CREATE_FROM_ENTITY(ctx, newE), entityType);
    }
    static FROM_ENTITY_STATE(ctx, entityState, entityType) {
        return new EPhysicsCtx(ctx, entityState.pose, entityState, entityType);
    }
    clone() {
        return new EPhysicsCtx(this.ctx, this.state.pose, this.state.clone(), this.entityType);
    }
    get height() {
        var _a;
        if (this.entityType.type === "player") {
            return EPhysicsCtx.playerPoseContext[this.pose].height;
        }
        return (_a = this.entityType.height) !== null && _a !== void 0 ? _a : 0;
    }
    get width() {
        var _a;
        if (this.entityType.type === "player") {
            return EPhysicsCtx.playerPoseContext[this.pose].width;
        }
        return (_a = this.entityType.width) !== null && _a !== void 0 ? _a : 0;
    }
    getHalfWidth() {
        return this.width / 2;
    }
    getCurrentBBWithPose() {
        const halfWidth = this.getHalfWidth();
        return new mineflayer_util_plugin_1.AABB(this.position.x - halfWidth, this.position.y, this.position.z - halfWidth, this.position.x + halfWidth, this.position.y + this.height, this.position.z + halfWidth);
    }
    getBBWithPose(position) {
        const halfWidth = this.getHalfWidth();
        return new mineflayer_util_plugin_1.AABB(position.x - halfWidth, position.y, position.z - halfWidth, position.x + halfWidth, position.y + this.height, position.z + halfWidth);
    }
    getBB(position) {
        var _a;
        const halfWidth = this.entityType.width ? this.entityType.width / 2 : 0;
        return new mineflayer_util_plugin_1.AABB(position.x - halfWidth, position.y, position.z - halfWidth, position.x + halfWidth, position.y + ((_a = this.entityType.height) !== null && _a !== void 0 ? _a : 0), position.z + halfWidth);
    }
}
exports.EPhysicsCtx = EPhysicsCtx;
EPhysicsCtx.loadData = load;
/**
 * From minecraft's Player.java file.
 */
EPhysicsCtx.playerPoseContext = {
    0: { width: 0.6, height: 1.8 },
    1: { width: 0.2, height: 0.2 },
    2: { width: 0.6, height: 0.6 },
    3: { width: 0.6, height: 0.6 },
    4: { width: 0.6, height: 0.6 },
    5: { width: 0.6, height: 0.6 },
    6: { width: 0.6, height: 1.5 },
    7: { width: 0.2, height: 0.2 },
};
